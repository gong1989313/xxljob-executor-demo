# xxl-job任务配置说明(路由策略,阻塞处理策略,失败处理策略)

## 路由策略

### 第一个
- `第一个`路由策略的逻辑非常简单: 就是调度中心直接把任务调度给从系统集群(如用户系统)的在线机器的列表中的第一个
![](res/userSystem_cluster.png)
- 在上图中会把任务调度给集群中端口为`9899`的机子
- 源码如下:
```java
public class ExecutorRouteFirst extends ExecutorRouter {
    //直接返回地址列表中的第一个地址
    public String route(int jobId, ArrayList<String> addressList) {
        return addressList.get(0);
    }

    @Override
    public ReturnT<String> routeRun(TriggerParam triggerParam, ArrayList<String> addressList) {

        // 获得同一执行器集群中的要执行被调度的任务的机子地址
        String address = route(triggerParam.getJobId(), addressList);

        // run executor
        ReturnT<String> runResult = XxlJobTrigger.runExecutor(triggerParam, address);
        runResult.setContent(address);
        return runResult;
    }
}
```

### 最后一个
- `最后一个`路由策略与`第一个`路由策略相反,调度中心把任务调度给集群中的最后一个机子

### 轮询
- `轮询`策略会依次把任务交给集群`online机器`列表中的执行(首次执行会随机找一个机子),如用户系统中的更改密码任务:
    - 先假设地址列表有用户`userSystem`,`userSystem2`,`userSystem3`,`userSystem4`的地址
    - 在第一个第1秒时,先随机找个机子运行任务,第一次执行任务的是`userSystem2`
    - 在第一个第30秒时,执行任务的是`userSystem3`
    - 在第二个第1秒是,执行任务的是`userSystem4`
    - 在第二个第30秒是,执行任务的是`userSystem`
    - 以此类推

### 随机
- `随机`路由策略就是每次都把任务交给集群中**随机**一台机子执行

### 一致性HASH
- `一致性HASH`路由策略使得不同任务均匀散列在不同机器上，保证分组下机器分配任务平均；且每个任务固定调度其中一台机器；
- 以用户系统的密码更改任务和用户信息打印任务为例(本机运行情况):
    - 先假设地址列表有用户`userSystem`,`userSystem2`的地址
    - 密码更改任务只会交给`userSystem2`执行,用户信息打印任务则只会交给`userSystem`执行

### 最不经常使用
- `最不经常使用`路由策略使得在单个JOB对应的每个执行器中，使用频率(次数)最低的优先被选作为执行任务的机子.
- 任务第一次执行时会首先随机初始化使用频率(次数),而随机找个机子执行
- 注意:
    - `使用次数`只记录配置这个路由策略时的使用次数,所以从其他路由策略第一次转这个策略时,使用频率(次数)会初始化.
    - 每隔一段时间(24小时),`使用次数`都会随机初始化一次

### 最近最久未使用
- `最近最久未使用`路由策略使得单个JOB对应的每个执行器，最久未使用的优先被选举.
- 注意:
    - 这个功能是由`LinkedHashMap`的访问排序特效实现的,并且从其他路由策略第一次转这个策略时,会从新创建一个`LinkedHashMap`,这是使用时间等信息也会清掉.
    - 每隔一段时间(24小时),都会从新初始化一次`LinkedHashMap`
### 故障转移
- 按照顺序依次进行心跳检测，第一个心跳检测成功的机器选定为目标执行器并发起调度；
    - 虽然xxl-job即使没有路由`故障转移`策略也会定时对注册的机子(执行器)进行心跳检测,但若执行器刚好在心跳检测后挂掉的话用前面几个策略是有可能把任务交给挂掉的机子(执行器)执行的.**[重要]**
    
### 忙碌转移
- 按照顺序依次进行空闲检测，第一个空闲检测成功的机器选定为目标执行器并发起调度；

### 分片广播
- 广播触发对应集群中所有机器执行一次任务，同时传递分片参数；
- 可根据分片参数开发分片任务；
- 也可以不处理参数,这样相当于任务的一次调度对应执行器集群里的所有机子都会执行(之前的策略中一次调度里,调度中心只会把任务交给集群中的一台机子执行)

## 阻塞处理策略
- 阻塞处理策略：调度过于密集执行器来不及处理时的处理策略；
    - 单机串行（默认）：调度请求进入单机执行器后，调度请求进入FIFO队列并以串行方式运行；
    - 丢弃后续调度：调度请求进入单机执行器后，发现执行器存在运行的调度任务，本次请求将会被丢弃并标记为失败；
    - 覆盖之前调度：调度请求进入单机执行器后，发现执行器存在运行的调度任务，将会终止运行中的调度任务并清空队列，然 - 后运行本地调度任务；


## 失败处理策略
- 调度失败:调度中心把任务分配给执行器失败
- 执行失败:执行器执行任务时失败
- 无论是调度失败还是执行失败,对失败的处理都是在调度中心完成(执行器始终只负责执行任务和返回结果)
- 失败处理策略；调度失败时的处理策略；
    - 失败告警（默认）：调度失败和执行失败时，都将会触发失败报警，默认会发送报警邮件；
    - 失败重试：
        - 调度失败时，除了进行失败告警之外，还会自动重试一次；
        - 执行失败时，根据回调返回值判断是否重试,若任务完后的返回值不是`ReturnT.SUCCESS_CODE`则进行重试；
        - 注意:
          - 都只有一次重试机会

## 子任务
每个任务都拥有一个唯一的任务ID(任务ID可以从任务列表获取)，当本任务执行结束并且执行成功时，将会触发子任务ID所对应的任务的一次主动调度。